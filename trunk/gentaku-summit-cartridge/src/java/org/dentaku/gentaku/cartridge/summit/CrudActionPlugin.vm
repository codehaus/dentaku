#set( $Q = '"' )
   
#macro( fetchselector $classView  )
		#set ( $arraycount = 0 )

	    String filter = new String(); 
		#foreach($selectorname in ${classView.selectorNames})
			#set ( $typecount = 0 )
			#foreach($typeentry in ${classView.selectorTypes})
				#if($typecount == $arraycount)
					#set ( $type = $typeentry )
				#end
				#set ( $typecount = $typecount+1 )
			#end
			#if($arraycount == 0)

		filter = $Q${selectorname} == aData.getParameters().getString(${selectorname})${Q} );
			#else

		filter += $Q && ${selectorname} == aData.getParameters().getString(${selectorname})${Q} );
			#end
			#set ( $arraycount =  $arraycount + 1 )
		#end

		Query q = pm.newQuery (${classView.entityclassname}.class, filter);
		// Have to assume there is only one
		q.setUnique (true);
		${classView.entityclassname} aObject = (${classView.entityclassname}) q.execute(); 
#end
 
/**
 * $dontedit
 * Be nice to supply a base class and allow user to extend, 
 * but most extensions can be managed by adding valves to pipeline 
 */
package ${metadata.packageName}.action;

#set ( $entitieswithcrud = $SummitHelper.getCrudList() )
#set ( $viewrefclasses = $rootClassView.getAllDependentClassEntity() )

package ${metadata.packageName}.actions;

import org.codehaus.dentaku.summit.modules.actions.CrudAction;
import org.codehaus.dentaku.summit.modules.actions.FkException;
import ${metadata.packageName}.model.*;
import ${metadata.packageName}.util.*;

import org.codehaus.plexus.summit.parameters.SummitRequestParameterParser;
import org.codehaus.plexus.summit.rundata.RunData;
import org.codehaus.plexus.jdo.JDOService;

import javax.jdo.PersistanceManager;
import javax.jdo.Extent;
import javax.jdo.Query;

import org.apache.velocity.context.Context;

import java.util.*;
/**
 * Insert/Update/Delete instances of domain records
 * then populate the context ready to be rendered by the Velocity page.
 */
public class Crud${ScreenName}} extends CrudAction {

	private JDOService jdos;

    public Crud${ScreenName} {
		jdos = { JDOService ) lookup( JDOService.ROLE );
	}

#foreach($viewclass in $entitieswithcrud)
    /**
     * Persist a new instance of ${viewclass.entityclassname}
     */
    public void doCreate${viewclass.entityclassname}(RunData aData, Context aContext) {
		doPreAction(aData, aContext);
		if(aContext.get(${Q}errMessage${Q}) !=null)
			populateContext(aData, aContext);
        try {
            logParameters(aData, ${Q}Crud${viewclass.entityclassname}.create()${Q});

            ${viewclass.entityclassname} instance = new ${viewclass.entityclassname}();

            // setProperties throws if the id has not been initialised,
            // as will occur if nothing has been previously selected from
            // the drop-down list (e.g. when no entities exist in the
            // record).
            ParameterParser parser = aData.getParameters();
            parser.setProperties(instance);

			PersistanceManager pm = jdos.getPersistenceManagerFactory().getPersistenceManager();
			try {
                tx.begin();       
    			pm.makePersistent(instance);
                tx.commit();
            }
            finally
            {
                if (tx.isActive()) {
                    tx.rollback();
                }
                pm.close();
			}
    		doPostAction(aData, aContext);
    		if(aContext.get(${Q}errMessage${Q}) != null)
    			populateContext(aData, aContext);

			try {
				populateContextWithSelected${viewclass.entityclassname}(instance, aData, aContext);
#foreach (${parentclass} in ${viewclass.ancestors})
	            populateContextWith${parentclass.entityclassname}(aData, aContext);
#end
            } catch (Exception e) {
                handleException(aContext, ${Q}Crud${ScreenName}.doCreate${viewclass.entityclassname}()${Q},
                    ${Q}Unable to populate context with ${viewclass.entityclassname} details${Q}, e);
            }
        } catch (Exception e) {
            handleException(aContext, ${Q}Crud${ScreenName}.doCreate()${Q},
                ${Q}Unable to create ${viewclass.entityclassname}${Q}, e);
        }
    }


    /**
     * Update an existing instance of ${viewclass.entityclassname}
     */
    public void doUpdate${viewclass.entityclassname}(RunData aData, Context aContext) {
		doPreAction(aData, aContext);
		if(aContext.get(${Q}errMessage${Q}) !=null)
			populateContext(aData, aContext);
        try {
            logParameters(aData, ${Q}${viewclass.entityclassname}.update()${Q});

            ${viewclass.entityclassname} instance = new ${viewclass.entityclassname}();
            ParameterParser parser = aData.getParameters();
            parser.setProperties(instance);

			PersistanceManager pm = jdos.getPersistenceManagerFactory().getPersistenceManager();
			try {
                tx.begin();       
    			pm.makePersistent(instance);
                tx.commit();
            }
            finally
            {
                if (tx.isActive()) {
                    tx.rollback();
                }
                pm.close();
			}

    		doPostAction(aData, aContext);
    		if(aContext.get(${Q}errMessage${Q}) != null)
    			populateContext(aData, aContext);

			try {
				populateContextFollowingUpdateWith${viewclass.entityclassname}(instance, aData, aContext);
#foreach (${parentclass} in ${viewclass.ancestors})
                populateContextWith${parentclass.entityclassname}(aData, aContext);
#end
         } catch (Exception e) {
                handleException(aContext, ${Q}Crud${ScreenName}.doUpdate${viewclass.entityclassname}()${Q},
                    ${Q}Unable to populate context with instance details${Q}, e);
            }
        } catch (Exception e) {
            handleException(aContext, ${Q}Crud${ScreenName}.doUpdate${viewclass.entityclassname}()${Q},
                ${Q}Unable to update instance${Q}, e);
        }
    }

    /**
     * Delete an instance of ${viewclass.entityclassname}
     */
    public void doDelete${viewclass.entityclassname}(RunData aData, Context aContext) {
		doPreAction(aData, aContext);
		if(aContext.get(${Q}errMessage${Q}) !=null)
			populateContext(aData, aContext);
        try {
            logParameters(aData, ${Q}Crud${viewclass.entityclassname}.delete()${Q});

            ${viewclass.entityclassname} instance = new ${viewclass.entityclassname}();
            ParameterParser parser = aData.getParameters();
            parser.setProperties(instance);

			PersistanceManager pm = jdos.getPersistenceManagerFactory().getPersistenceManager();
			try {
                tx.begin();       
    			pm.deletePersistent(instance);
                tx.commit();
            }
            finally
            {
                if (tx.isActive()) {
                    tx.rollback();
                }
                pm.close();
			}
    		doPostAction(aData, aContext);
    		if(aContext.get(${Q}errMessage${Q}) != null)
    			populateContext(aData, aContext);

            contextMessage(aContext,
                ${Q}Confirmed deletion of record named ${viewclass.entityclassname}${Q});
				populateContextWithSelected${viewclass.entityclassname}(null, aData, aContext);
#foreach (${parentclass} in ${viewclass.ancestors})
				populateContextWith${parentclass.entityclassname}(aData, aContext);
#end
	    } catch (Exception e) {
            handleException(aContext, ${Q}Crud${ScreenName}.doDelete${viewclass.entityclassname}()${Q},
                ${Q}Unable to delete record${Q}, e);
            populateContext(aData, aContext);
        }
    }
#end

    /**
     * Invoked when a form is submitted without a specific doPerform action.
     *
     * This action is fired when a specific record is selected in a HTML select
     * box, and serves to populate the aContext with the object representing
     * the record. The template then renders the page with the objects fields.
     */
    public void doPerform(RunData aData, Context aContext) {
		doPreAction(aData, aContext);
		if(aContext.get(${Q}errMessage${Q}) !=null)
			populateContext(aData, aContext);
        logParameters(aData, ${Q}Crud${ScreenName}.doPerform()${Q});

        String selectionType = aData.getParameters().getString(${Q}selectionType${Q});

        /*
           This method is invoked when the user modifies a drop-down list.
           Not possible to invoke a specific submit input from javascript
           (e.g. like doSubmit_blah), so instead the javascript sets a
           hidden parameter to identify which drop-down was used.
         */
        if (selectionType.equals(${Q}select${rootClassView.entityclassname}${Q})) {
            // The user has updated the ${rootClassView.entityclassname} list
            // In this case we only populate the context
            // with the selected rootselectable type, and effectively
            // remove all other selections from the context
            populateContextWith${rootClassView.entityclassname}(aData, aContext);
        } 
#foreach($viewrefclass1 in $viewrefclasses)
		else if (selectionType.equals(${Q}selected${viewrefclass1.entityclassname}${Q})) {
            // An event has originated from the ${viewrefclass1.entityclassname} drop-down
            // In this case, we want to populate the context with
            // the selection down to the ${viewrefclass1.entityclassname} lists,
            // but not beyond, since these will be invalid now
            // that a new ${viewrefclass1.entityclassname} has been chosen.
            populateContextWith${viewrefclass1.entityclassname}(aData, aContext);
        } 
#end
		doPostAction(aData, aContext);
		if(aContext.get(${Q}errMessage${Q}) != null)
			populateContext(aData, aContext);
	}
    /**
     * The selector attribute should always reside in the context so that drop-down
     * lists can be populated by a pull tool
     */
    protected void populateContextWith${rootClassView.entityclassname}(RunData aData, Context aContext) {
		#fetchselector($rootClassView)
        if (aObject != null) {
            aContext.put(${Q}selected${rootClassView.entityclassname}${Q}, aObject);
            ${rootClassView.entityclassname}.setSelectedObject(aObject);
        }
    }
	protected void populateContextFollowingUpdateWith${rootClassView.entityclassname}(
		${rootClassView.entityclassname}instance, RunData aData, Context aContext) {
		// Updated root object and currently selected child objects put into RunData
        if (instance != null) {
            aContext.put(${Q}selected${rootClassView.entityclassname}${Q}, instance);
            ${rootClassView.entityclassname}.setSelectedObject(instance);
        }
#set ( ${childclasses} = ${rootClassView.children} )
#foreach ( ${childclass} in ${childclasses} )
		${childclass.entityclassname} instance = new ${childclass.entityclassname}();
		ParameterParser parser = aData.getParameters();
		parser.setProperties(instance);
        populateContextWithSelected${childclass.entityclassname}(instance, aData, aContext);
#end

	}

#foreach($viewrefclass2 in $viewrefclasses)
    /**
     * The selector attribute should always reside in the context so that drop-down
     * lists can be populated by a pull tool
     */
    protected void populateContextWith${viewrefclass2.entityclassname}(RunData aData, Context aContext) {
		#fetchselector($viewrefclass2)
        if (aObject != null) {
            aContext.put(${Q}selected${viewrefclass2.entityclassname}${Q}, aObject);
            //${viewrefclass2.entityclassname}.setSelectedObject(aObject);
        }
    }
    protected void populateContextWithSelected${viewrefclass2.entityclassname}(${viewrefclass2.entityclassname} instance, RunData aData, Context aContext) {
        if (instance != null) {
            aContext.put(${Q}selected${viewrefclass2.entityclassname}${Q}, instance);
            //${viewrefclass2.entityclassname}.setSelectedObject(instance);
        }
    }
#end

    /**
     * Normally used for recovering the screen values after an exception
	 * pays attention to current context.
	 * Returns objects currently in context along with the error message
     */
    protected void populateContext(RunData aData, Context aContext) {
        // This could be done with javascript, but stick with the convention
		${rootClassView.entityclassname} instance = new ${rootClassView.entityclassname}();
		ParameterParser parser = aData.getParameters();
		parser.setProperties(instance);
        populateContextWithSelected${rootClassView.entityclassname}(instance, aData, aContext);
#foreach ($viewrefclass3 in $viewrefclasses)
		${viewrefclass3.entityclassname} instance = new ${viewrefclass3.entityclassname}();
		parser.setProperties(instance);
        populateContextWith${viewrefclass3.entityclassname}(instance, aData, aContext);
#end
    }
}
